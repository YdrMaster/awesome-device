# awesome-device

内存映射 I/O（mmio）是 CPU 访问外设的一种典型方式。它的主要特征是将一块物理地址空间重定向到外设地址空间，使 CPU 能够透明地访问外设。这样的硬件设计对于系统软件的编程产生了一种正面的影响：**访问外设现在可以和访问其他一些特殊的内存区域统一起来了**。这种软硬协同的方式很类似带 MMU 的 CPU 对物理内存中页表的理解：读写这块地址空间就会修改硬件的工作状态。使用它的方式又像是在运行时检查那些由链接器放在指定位置的信息。

举例来说，`qemu-system-riscv64` 的 `virt` 仿真器，0x1000_0000 开始的一段地址空间映射到一个 8 位 16550 兼容串口外设，这也是这台虚拟机的主要控制台外设。对于系统软件开发者来说，这可以理解为 0x1000_0000 处放置着一个由手册描述的硬件寄存器决定的数据结构，读写这个数据结构硬件就能操作外设。同时，不同的物理硬件上，同一种外设的结构是相同的，只是映射的物理地址空间可能不同。

那么——一个很自然的想法——为什么不直接把这个结构定义出来做成库，以便在不同的软件和硬件上复用呢？

过去，已经有很多开发者开发了许多 mmio 驱动软件。这些驱动软件总是试图通过一个变量来描述在地址空间上的位置。这个看似正常的变量其实带来不少问题，比如在那些不具备跨平台需求，追求极致性能和尺寸的嵌入式程序中。大量外设其实位于已知的、固定的位置，它们的地址完全可以作为一个常量随处内联，那些通过传入基址构造的驱动就无法内联。另外，对于一个硬件上多个相对位置固定的外设，也没有一种简单的方式将它们的驱动组合起来。典型的是 DMA 控制器，它总是需要和各种外设联动，开发 DMA 的驱动总是非常麻烦而且很难做到优雅。

在我看来，驱动作者应该少管闲事，而不是猜测用户要怎么使用外设。驱动要做的就是由硬件决定了的部分：寄存器的功能定义，以及它们的协同关系。驱动应该仅根据外设的手册来提供一个结构体以完成外设的操作，将结构体映射到内存空间的方式则由系统软件开发者控制。极端条件下，一个包括所有外设的链接脚本可以将整个定位过程提前到运行之前。组合多个驱动也变得简洁而且零开销：只需要把这些结构体放到一个大结构体里，并且填充合适的间距就可以了。驱动可以以递归的结构任意组合，并把任何操作下降到寄存器。

这个库就是按这个想法实现的驱动的列表。其中一些库已经发布，并在具体的项目中发挥作用：

- aclint: [![Latest version](https://img.shields.io/crates/v/aclint.svg)](https://crates.io/crates/aclint)
- plic: [![Latest version](https://img.shields.io/crates/v/plic.svg)](https://crates.io/crates/plic)
- sifive-test-device: [![Latest version](https://img.shields.io/crates/v/sifive-test-device.svg)](https://crates.io/crates/sifive-test-device)
- uart16550: [![Latest version](https://img.shields.io/crates/v/uart16550.svg)](https://crates.io/crates/uart16550)
